<!DOCTYPE html>
<html>
<head>
    <title>Shot Tracer - Browser Ball Tracker</title>
    <style>
        body { margin: 0; font-family: Arial; background: #000; color: #fff; }
        #container { display: flex; max-width: 1200px; margin: auto; }
        #videoPanel { flex: 1; position: relative; }
        #video, #canvas { width: 100%; height: auto; max-height: 600px; }
        #controls { position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.7); padding: 10px; }
        #traces { position: absolute; top: 10px; right: 10px; }
        canvas { position: absolute; top: 0; pointer-events: none; }
    </style>
</head>
<body>
    <div id="container">
        <div id="videoPanel">
            <video id="video" controls></video>
            <canvas id="canvas"></canvas>
            <div id="controls">
                <input type="file" id="upload" accept="video/*">
                <label><input type="checkbox" id="trace" checked> Trace</label>
                <label><input type="checkbox" id="smooth" checked> Smooth</label>
                <button id="clear">Clear</button>
            </div>
            <div id="traces">
                <div>FPS: <span id="fps">0</span></div>
                <div>Points: <span id="points">0</span></div>
            </div>
        </div>
    </div>

    <script>
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const upload = document.getElementById('upload');
        const traceCB = document.getElementById('trace');
        const smoothCB = document.getElementById('smooth');
        const clearBtn = document.getElementById('clear');
        
        let frameData, width, height, prevGray, trajectory = [], kalman = new Kalman();
        let fpsCounter = { last: 0, frames: 0 }, bgFrame = null;
        let isTracking = false;

        // Simple 1D Kalman filter for position smoothing
        class Kalman {
            constructor() {
                this.x = 0; this.p = 1; this.q = 0.1; this.r = 1; this.k = 0;
            }
            update(z) {
                this.p += this.q;
                this.k = this.p / (this.p + this.r);
                this.x += this.k * (z - this.x);
                this.p *= (1 - this.k);
                return this.x;
            }
        }

        // HSV color space conversion
        function rgbToHsv(r, g, b) {
            r /= 255; g /= 255; b /= 255;
            const max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h, s = max === 0 ? 0 : (max - min) / max, v = max;
            const d = max - min;
            if (max === min) h = 0;
            else if (max === r) h = (g - b) / d + (g < b ? 6 : 0);
            else if (max === g) h = (b - r) / d + 2;
            else h = (r - g) / d + 4;
            return [h / 6, s, v];
        }

        // Detect golf ball (white/bright circle on grass/sky)
        function findBall(frameData, w, h) {
            const balls = [];
            for (let i = 0; i < frameData.data.length; i += 4 * 8) { // Sample every 8px
                const x = (i / 4) % w, y = Math.floor((i / 4) / w);
                if (x < 20 || x > w-20 || y < 20 || y > h-20) continue;
                
                const r = frameData.data[i], g = frameData.data[i+1], b = frameData.data[i+2];
                const hsv = rgbToHsv(r, g, b);
                const bright = (r + g + b) / 3 > 180;
                const white = hsv[1] < 0.3 && hsv[2] > 0.8; // Low saturation, high value
                
                if (bright && white) {
                    // Check circularity (local variance)
                    let neighbors = 0, sumX = 0, sumY = 0;
                    for (let dy = -5; dy <= 5; dy++) for (let dx = -5; dx <= 5; dx++) {
                        if (dx*dx + dy*dy > 25) continue;
                        const nx = x + dx, ny = y + dy;
                        if (nx >= 0 && nx < w && ny >= 0 && ny < h) {
                            const idx = (ny * w + nx) * 4;
                            if (frameData.data[idx+2] > 150) { // Blue channel for sky contrast
                                neighbors++; sumX += nx; sumY += ny;
                            }
                        }
                    }
                    if (neighbors > 10) {
                        balls.push({x: sumX / neighbors, y: sumY / neighbors, score: neighbors});
                    }
                }
            }
            return balls.length ? balls.reduce((best, curr) => curr.score > best.score ? curr : best) : null;
        }

        // Optical flow (simple block matching)
        function opticalFlow(prev, curr, px, py) {
            let bestMatch = 1000, bestDx = 0, bestDy = 0;
            for (let dy = -10; dy <= 10; dy++) for (let dx = -10; dx <= 10; dx++) {
                const score = blockDiff(prev, curr, px, py, dx, dy);
                if (score < bestMatch) {
                    bestMatch = score; bestDx = dx; bestDy = dy;
                }
            }
            return {x: px + bestDx, y: py + bestDy};
        }

        function blockDiff(prev, curr, px, py, dx, dy) {
            let diff = 0;
            for (let by = -5; by <= 5; by++) for (let bx = -5; bx <= 5; bx++) {
                const pidx = ((py+by)*width + (px+bx))*4;
                const cidx = ((py+by+dy)*width + (px+bx+dx))*4;
                diff += Math.abs(prev.data[pidx] - curr.data[cidx]);
            }
            return diff;
        }

        function processFrame() {
            if (!isTracking || video.paused || video.ended) return;
            
            ctx.drawImage(video, 0, 0, width, height);
            frameData = ctx.getImageData(0, 0, width, height);
            
            const ball = findBall(frameData, width, height);
            if (ball && trajectory.length) {
                const last = trajectory[trajectory.length-1];
                const tracked = opticalFlow(prevGray, frameData, last.x, last.y);
                const smoothedX = kalman.update(tracked.x);
                const smoothedY = kalman.update(tracked.y);
                
                trajectory.push({x: smoothedX, y: smoothedY, t: Date.now()});
                
                // Keep only recent points for trail
                if (trajectory.length > 200) trajectory.shift();
            } else if (ball) {
                trajectory = [{x: ball.x, y: ball.y, t: Date.now()}];
            }
            
            prevGray = frameData; // Simplified grayscale
            
            // Draw trajectory
            if (traceCB.checked && trajectory.length > 1) {
                ctx.strokeStyle = smoothCB.checked ? '#00ff0040' : '#ff000080';
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(trajectory[0].x, trajectory[0].y);
                for (let i = 1; i < trajectory.length; i++) {
                    ctx.lineTo(trajectory[i].x, trajectory[i].y);
                }
                ctx.stroke();
                
                // Ball highlight
                if (ball) {
                    ctx.fillStyle = '#ffff00';
                    ctx.beginPath();
                    ctx.arc(ball.x, ball.y, 8, 0, Math.PI*2);
                    ctx.fill();
                }
            }
            
            // FPS
            const now = performance.now();
            fpsCounter.frames++;
            if (now - fpsCounter.last > 1000) {
                document.getElementById('fps').textContent = Math.round(fpsCounter.frames * 1000 / (now - fpsCounter.last));
                fpsCounter.frames = 0; fpsCounter.last = now;
            }
            document.getElementById('points').textContent = trajectory.length;
            
            requestAnimationFrame(processFrame);
        }

        // Event handlers
        upload.addEventListener('change', e => {
            const file = e.target.files[0];
            video.src = URL.createObjectURL(file);
            trajectory = []; kalman = new Kalman();
        });
        
        video.addEventListener('loadedmetadata', () => {
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            width = canvas.width; height = canvas.height;
            isTracking = true;
            requestAnimationFrame(processFrame);
        });

        video.addEventListener('play', () => isTracking = true);
        video.addEventListener('pause', () => isTracking = false);
        clearBtn.addEventListener('click', () => trajectory = []);
    </script>
</body>
</html>
